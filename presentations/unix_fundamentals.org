#+TITLE: UNIX Fundamentals
#+AUTHOR: Heikki Lehv\auml{}slaiho
#+EMAIL:     heikki.lehvaslaiho@kaust.edu.sa
#+DATE:      2011-11-19 \\ CC BY-SA 3.0
#+DESCRIPTION:
#+KEYWORDS: UNIX, LINUX , CLI, history, summary, command line  
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:

#+startup: beamer
#+LaTeX_CLASS: beamer
##+LaTeX_CLASS_OPTIONS: [bigger]

#+BEAMER_FRAME_LEVEL: 2

#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)

# TOC slide before every section
#+latex_header: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Topic}\tableofcontents[currentsection]\end{frame}}

## see http://deic.uab.es/~iblanes/beamer_gallery/

##+latex_header: \mode<beamer>{\usetheme{Madrid}}
#+latex_header: \mode<beamer>{\usetheme{Antibes}}
##+latex_header: \mode<beamer>{\usecolortheme{wolverine}}
#+latex_header: \mode<beamer>{\usecolortheme{beaver}}
#+latex_header: \mode<beamer>{\usefonttheme{structurebold}}

#+latex_header: \logo{\includegraphics[width=1cm,height=1cm,keepaspectratio]{img/logo-kaust}}

## define colours for code listings
\definecolor{keywords}{RGB}{255,0,90}
\definecolor{comments}{RGB}{60,179,113}
\definecolor{fore}{RGB}{249,242,215}
\definecolor{back}{RGB}{51,51,51}
\lstset{
  basicstyle=\color{fore},
  keywordstyle=\color{keywords},
  commentstyle=\color{comments},
  backgroundcolor=\color{back}
}
* Aims of the course
** Aims
Students are to be comfortable in using the command line to:
  + Issue UNIX commands to 
    - Move in the file hierarchy
    - Manage files
    - Interrogate text files
  + Edit text files in a text editor
  + Connect to a remote computer
  + Configure bash shell  environment
  + Put together simple bash script files

* Philosophy of command line
** CLI versus GUI

- Philosophical
  + Command line forces internalization of the problem by abstraction
- Practical
  + Scientific data sets are too big for GUI
  + Scientific data does not come in standard formats

** Practical differences

*** GUI 					      :B_ignoreheading:BMCOL:
    :PROPERTIES: 
    :BEAMER_env: block
    :BEAMER_col: 0.5
    :END:
    - Depends on reading the file into memory and manipulating it there.
    - Only a limited number of commands fit in  menus
    - Can not be automated
    \nbsp

*** CLI 						    :BMCOL:B_example:
    :PROPERTIES: 
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:
    - Work in chunks, e.g. line by line
    - Programmes are designed to work together
    - Output from one is the next programme's input 
    This is instant programming

** Progression in CLI usage

1. One at the time (learn the commands)
2. Chain them together (IO redirection)
3. Store them for later use (shell aliases and functions)
4. Create your own (any programming language, bash/perl)

The aim is for efficiency, speed and convenience

** Further reading

In the Beginning was the Command Line: \\   http://www.cryptonomicon.com/beginning.html

* UNIX operating system
** Operating system

An operating system (OS) is software, consisting of programs and data,
that runs on computers, manages computer hardware resources, and
provides common services for execution of various application
software.

*** list 					      :B_ignoreheading:BMCOL:
    :PROPERTIES: 
    :BEAMER_env: ignoreheading
    :BEAMER_col: 0.6
    :END:
    Operating system types:
    - Real-time
    - Multi-user vs. Single-user
    - Multi-tasking vs. Single-tasking
    - Distributed
    - Embedded

*** list 					      :B_ignoreheading:BMCOL:
    :PROPERTIES: 
    :BEAMER_col: 0.4
    :BEAMER_env: ignoreheading
    :END:
    #+ATTR_LaTeX: width=0.6\textwidth
    [[file:img/Operating_system_placement.pdf]]
    \\ \tiny Image from from Wikimedia Commons, CC BY-SA 3.0.


** Unix and Unix-like operating systems

Main features:

- multitasking
- multi-user
- memory protection

Originally developed in 1969 by a group of AT&T employees at Bell
Labs, including Ken Thompson, Dennis Ritchie, Brian Kernighan,
Douglas McIlroy, and Joe Ossanna.

- Developed in an environment of free information exchange
- Became heavily fragmented and  commercialised once companies noticed its value
- GNU project for free OS started by Richard Stallman in early 80's
  + “GNU's Not Unix!”
** Brief History of UNIX

   #+ATTR_LaTeX: width=0.95\textwidth
   [[file:img/Unix_history-simple.pdf]] 
   \\ \tiny Image from from Wikimedia Commons, CC BY-SA 3.0.

** Our course computers run MacOSX

- Mac OSX, a variation of BSD UNIX
- Most servers and workstations in science run LINUX

There are subtle differences in tools and how they work between
UNIXes.

It is possible to install the GNU tools to a Mac

- The Fink project http://www.finkproject.org/
- MacPorts http://www.macports.org/

Increasingly, there are native ports of free GUI programs to MacOS X.
- Aquamacs

** Brief History of LINUX (I)

- Linux began in 1980's as an effort to create a free Unix-like operating system
- The project was called GNU and was run by the Free Software Foundation (FSF) created by Richard Stallman
- Development began with system tools such as editors, a compiler and hundreds of other utilities
- By early 1990's most of the components were written, but the operating system was missing a kernel
- Coincidentally, Linus Torvalds of Helsinki University had been working on a Unix-based kernel – the first version was completed in 1994

** Brief History of LINUX (II)

- Linus liked the endeavours of the Free Software Foundation and
  released his kernel under the GNU GPL (The GNU General Public
  License)

- The Linux kernel and GNU tools made a complete, free operating
  system: the GNU/Linux operating system

** Open Source Licenses
- GPL was one of the most important contributions of the FSF
- The Open Source definition (http://www.opensource.org) is based on the GPL
- Open Source licenses ensure basic freedoms, including:
  + The freedom to use the software for any purpose
  + The freedom to distribute the software to others
  + The freedom to modify the software
  + The freedom to distribute the modified software to others (under the same licensing conditions)
- GPL, MPL and BSD licenses are some examples

** User Interface
- Describes the way a system interacts with its users
- Text-based or command line interface:
  - Dates back to pre 1980's
  - Commands typed using keyboard to run applications
  - Less user-friendly but extremely flexible, especially for system administration

** Graphical interface:

- Point and click to run applications
- Interaction with system easier and quicker to learn

- Unix provides both and can be set up to boot in either text mode or
  graphical mode
  - common GUIs in LINUX: Gnome, KDE
  - many different "window amanagers" are availble
  - Mac OS X GUI is proprietary Aqua

** Logging In

- Since UNIX is a multiuser operating system, users must authenticate
  themselves before gaining access

- Authentication is done with a username and password, configured by
  the system administrator

- Although visually different, the process of logging is the same in
  both text and graphical mode

- The combination of username, password and disk space for personal
  files is called a user account

- *Note* that UNIX is case-sensitive

** Changing Passwords

- To change your password, type the command \texttt{passwd} at a shell

- You will be prompted for a new password, and a confirmation - after
  confirming your current password

- Bad passwords are disallowed.
   + Passwords should be at least 6 characters long, contain both
     letters and digits or punctuation and must not be based on
     dictionary words

- There is usually a graphical utility for changing passwords
  accessible from the application menu (this is desktop-specific)

** Getting Help on Commands

- Command: man [section] name
- Common options:
  + \texttt{ -k}: searches for keywords in man page entries (\texttt{apropos)
- Standard use displays the manual page of the command
- The section number may need to be specified for keywords that have
  more than one entry in the system
- Examples:

#+BEGIN_SRC shell -n
   man ls
   man -k cron
   apropos cron
   man 5 crontab
#+END_SRC

* UNIX file system
** File System Basics (I)

- Files are entities for storing data in a computer system

- There are many types of files: various data files and programs; even
  devices are represented as files

- Filename extensions are a convenience for the user – the operating
  system does not derive any meaning from it

- Some common extensions include:
  - .bz2: File zipped with the bzip2 utility
  - .c: C source code file
  - .gif/.jpg/.png: Image files (GIF / JPEG / PNG)
  - .gz: File zipped with the gzip utility
  - .zip: File compressed with the zip utility

** File System Basics (II)

- Common extensions (cont.):
  - .html: Web page
  - .mp3: MP3 audio file
  - .pdf: PDF document format
  - .pl: Perl script
  - .rpm: RedHat software package
  - .odt: OpenOffice.org files (writer / calc / impress / draw)
  - .tar: Archive created with the tar utility
  - .txt: Plain text file

** Directory Hierarchy

- Files are grouped into logical units into collections called
  directories (known as folders in other OS's)

- Directories may contain subdirectories, resulting in a hierarchical
  structure

- The top-most directory in this tree is called the root directory,
  denoted by a /

- Each user has a directory set aside for storing personal files –
  this is called his home directory – uniquely identified by the
  username e.g /home/dilbert

- Users should create new directories in their home directories to
  properly organise their files

** Important directories in Linux

Macs (BSD Unix) follow slightly different conventions!

*** list 					      :B_ignoreheading:BMCOL:
    :PROPERTIES: 
    :BEAMER_env: ignoreheading
    :BEAMER_col: 0.6
    :END:

- /bin
  + Basic system binaries (executables)
- /usr/bin
  + More system binaries
- /usr/local/bin
  + local (user installed) binaries
- /sbin
  + Basic system administrative programs
- /usr/sbin
  + More system administrative programs.
*** list 					      :B_ignoreheading:BMCOL:
    :PROPERTIES: 
    :BEAMER_env: ignoreheading
    :BEAMER_col: 0.6
    :END:
- /etc
  + Et cetera. Systemwide configuration scripts 
- /etc/rc.d or /etc/init.d
  + Boot scripts
- /usr/share/doc
  + Documentation for installed packages
- /usr/man
  + The systemwide manpages
- /dev
  + Device directory

** More important directories in Linux
*** list 					      :B_ignoreheading:BMCOL:
    :PROPERTIES: 
    :BEAMER_env: ignoreheading
    :BEAMER_col: 0.6
    :END:
- /proc
  + Process directory
- /sys
  + Systemwide device directory.
- /mnt or /media
  + Mount, directory for mounting external drives
- /var
  + Variable (changeable) system files
- /var/log
  + Systemwide log files
*** list 					      :B_ignoreheading:BMCOL:
    :PROPERTIES: 
    :BEAMER_env: ignoreheading
    :BEAMER_col: 0.6
    :END:
- /var/spool/mail
  + User mail spool
- /lib
  + Systemwide library files
- /usr/lib
  + More systemwide library files
- /tmp
  + System temporary files (world writable)
- /boot
  + System boot directory

** Pathing

- The location of a file in the file system is known as its pathname
- For example:
  - /home/dilbert/admin/budget.doc
  - /usr/bin/less
  - A pathname uniquely defines the path from the root directory to a file
  - Note that applications are also files in the file system and have
    their own pathnames

** Example Directory Tree

#+ATTR_LaTeX: width=0.99\textwidth
[[file:img/unix_tree.pdf]]

** File Manipulation with the CLI

- Understanding paths is important when using the CLI

- *Absolute pathname*: a path that describes the location of the file
  from the root directory, e.g. /home/dilbert/admin/budget.doc

- *Relative pathname*: a path that described the location of the file
  from the current directory, e.g. admin/budget.doc

- A user is automatically placed in his home directory when logging in
  or opening a new terminal or shell

- The command \texttt{pwd} prints the current working directory

** Changing Directory

- The cd command is used to change directory – pathing rules apply, for example
  - cd /home/dilbert/admin
  - cd admin
-  Certain symbols have special meanings for directories
  - ~ refers to the user's home directory
  - . (dot) refers to the current directory
  - .. refers to the parent directory
  - - refers to the previous directory
- For example:

#+BEGIN_SRC shell -n
  cd ~/admin
  cd ../../bin
  cd -
#+END_SRC

** Moving in the directory structure

#+ATTR_LaTeX: width=0.99\textwidth
[[file:img/unix_tree_traversing.pdf]]

** Pathing Command Structure and Options

- Unix commands typically follow the structure:
#+BEGIN_SRC shell
   command [options] argument1 argument2 ...
#+END_SRC

- Options are shown in square brackets and are just that
  (optional). Options take the following forms:

  - Single dash followed by a single letter (e.g. -d; -h)
  - Double dash followed by the long name of the option
    (e.g. -\shy-delim; -\shy-help)

- Most commands support the -h and  -\shy-help options
- Arguments are the unnamed parts of the command at the end of the line

** Listing Files

- Command: \texttt{ls [options] [files]}
- Common options:
  + \texttt{-a}: shows all files, including hidden files
  + \texttt{-l}: uses long listing format
  + \texttt{-r}: produces output in reverse order
  + \texttt{-t}: sorts output by modification times
  + \texttt{-1}: lists one file per line
- Examples: 
  + \texttt{ls }(short file listing)
  + \texttt{ls -al} (long listing, including hidden files)
  + \texttt{ls -1} (short listing; one file per line)
  + \texttt{ls -lrt} (long listing; most recently accessed files last)

** Creating & Removing Directories
# Task: How would you create a directory /tmp/2011/10/24/ in one
# command?
# Hint: Read the mkrid man page
- To create a directory, use \texttt{mkdir <directory>}
#+BEGIN_SRC shell -n
  mkdir admin
  mkdir /home/dilbert/admin
#+END_SRC

- To remove a directory, use \texttt{rmdir <directory>}. Note that the directory must be empty
#+BEGIN_SRC shell
  rmdir admin
#+END_SRC

- Again, the pathing rules apply. The easiest method is to change
  into the directory first so that relative pathing can be used

** Copying Files

- Command: \texttt{cp [options] source destination}
- Common options:
  - \texttt{-f}: does not prompt before removing
  - \texttt{-i}: prompts before removing
  - \texttt{-r}: copies directories recursively

- Multiple files can be specified as the source, but only one
  destination can be specified (which may be a directory)

- Examples:
#+BEGIN_SRC shell -n
  cp budget.doc oldbudget.doc
  cp jan-budget.doc feb-budget.doc admin/
#+END_SRC

** Removing Files

- Command: \texttt{rm [options] files}
- Common options:
  + \texttt{-f}: does not prompt before removing
  + \texttt{-i}: prompts before removing
  + \texttt{-r}: removes directories recursively
- Examples:
#+BEGIN_SRC shell -n
  rm budget.doc
  rm budget.doc oldbudget.doc
  rm -r admin/ (to be used with care!)
#+END_SRC

** Renaming and Moving Files

- Command:  \texttt{mv [options] source destination}
- Common options:
  - \texttt{-f}: does not prompt before moving
  - \texttt{-i}: prompts before moving
- Multiple files can be specified as the source, but only one
  destination can be specified
- This command is also used to move and rename directories
- Examples:
#+BEGIN_SRC shell -n
  mv budget.doc oldbudget.doc
  mv budget.doc ../admin
  mv admin/ admin2003/
#+END_SRC

** Using Wildcards in Filenames

- Wildcards can be used to refer to multiple files
  - \texttt{*}: represents any string of characters
  - \texttt{?}: represents a single character
  - \texttt{[]}: defined sets or ranges
- Examples:

#+BEGIN_SRC shell -n
  ls *.doc
  mv *.doc olddocuments/
  rm *
  ls -l A???.txt
  ls [Aa]*png
  ls [a-z]*jpg
  rm -rf *  (!!!)
#+END_SRC

** Helpful CLI Features

- Tab completion: command and file names are completed as far as
  possible when the tab key is pressed. Double-tab key press shows
  available completions
- History: pressing the up arrow key scrolls backwards through the
  previous commands
- Events (\texttt{!}): previous events can be rerun using the !
  character and the first character(s) of the event. The most recent
  matching event is chosen. !! runs the most recent command
- Control-R allows live history searching
- These features are shell-dependent (bash supports all)
** Viewing File Contents

- \texttt{cat} utility: outputs the contents of a file to the terminal
- \texttt{less} utility: similar to cat, but displays one page of output at a
  time (improvement of more)
  + Press spacebar to advance to the next page
  + Press \texttt{B} to jump back to the previous page
  + Press Enter key to advance line at a time
  + Press up and down arrow keys to move a line at a time
  + search by pressing \texttt{/}, type the string and press enter
    (press n for next)
- \texttt{clear} utility: clears the screen
** Text Editors

- Unix offers a variety of text editors: vi (or vim), emacs, nedit,
  pico, jed, kwrite, etc.
- vi (and vim – vi-improved) is a command-driven editor that is found
  on almost all Unix-based systems
- Emacs is a GNU editor that offers a large amount of additional
  functionality. Its graphical interface and maturity make it an
  excellent choice of editor for the novice user.

** File System Security

- Unix file system security is a simple scheme based on users and groups
- Users belong to one or more groups, set by the system administrator (root)
- Groups allow file access to sets of users to be easily implemented
- Each file is owned by one user and allocated to one group
  - \texttt{chown}: change file owner
  - \texttt{chgrp}: change group
- A new file is created with the user as its owner and the user's
  current group as its group

** Privilege Types

- Files and directories may be granted read, write and execute permissions
- Each of these privileges are specified separately for:
  + the owner
  + the group
  + other users, who do not fall into the previous categories
- Tasks in a computer are controlled by assigning users to groups
  (command \textt{groups})
- Superuser (root/Manager) can do anything
** Privilege Semantics

- Privileges have different meanings for files and directories
- Privileges for files
  + *read* permission allows the file to be read, copied, printed, etc
  + *write* permission allows the file to be modified, overwritten and deleted
  + *execute* permission allows the file to be executed
- Privileges for directories
  + *read* permission allows the directory's contents to be listed
  + *write* permission allows files to be created and deleted in it
  + *execute* permission allows the user to change directory to it

** Viewing Permissions via CLI

#+BEGIN_SRC shell
-rw-r--r-- 1 heikki heikki 1772 2007-03-07 13:29 test.pdf
#+END_SRC

- The \texttt{ls -l} command shows file and directory permissions in
  the first column
- If the first character is a dash, then it represents a file. If it
  is a d, it represents a directory
- Characters 2-4 indicate the permissions of the owner (r = read, w =
  write, x = execute)
- Characters 5-7 indicate the permissions of the group
- Characters 8-10 indicate the permissions of other users
- Third column displays the owner
- Fourth column displays the group

** Modifying Permissions via CLI (I)

- Command: \texttt{chmod [options] mode files}
- Common options:
  - \texttt{-R}: applies the changes to directories recursively
- Mode specifies:
  - Entities to which the change should apply:
    + u = user
    + g = group
    + o = other
    + a = all
  - Whether permission should be granted (+) or revoked (-)
  - Permission types that should be granted or revoked: r, w and/or x

** Modifying Permissions via CLI (II)

- Examples:
  - \texttt{chmod g+rw budget.doc} (grants read and write access to group)
  - \texttt{chmod o-rx public\_html} (revokes read and execute permissions to others)
  - \texttt{chmod ug+x MakeBudget} (grants execute permission to user and group)
  - \texttt{chmod a+rwx public\_html} (not a good idea!)

** Modifying Permissions via CLI (III)

- Alternative, numeric, notation is to use three groups of octal digits
 from 0-7 to set all the permissions explicitly:


| dec | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| bin | 000 | 001 | 010 | 011 | 100 | 101 | 110 | 111 |
|-----+-----+-----+-----+-----+-----+-----+-----+-----|
| r   | -   | -   | -   | -   | r   | r   | r   | r   |
| w   | -   | -   | w   | w   | -   | -   | w   | w   |
| x   | -   | x   | -   | x   | -   | w   | -   | x   |

- Examples:

  + \texttt{chmod 700 myscript.sh} (user only executable)
  + \texttt{chmod 664 schedule.txt} (read by all, write by user and group)

** How to run a program?

1. Explicit path
  - Give absolute path
  - Execute bit must be set
2. use $PATH
  - Shell variable holding a list of executable directories
#+begin_src shell -n
  echo $PATH
  which echo
#+end_src

- \texttt{echo} is in \texttt{/bin/echo}
- Can you find /bin in the path list?
- \texttt{which} shows the path of an executable


** File System Command Summary

-  \texttt{pwd}	print working directory
-  \texttt{cd}	change directory
-  \texttt{ls}	list files and directories
-  \texttt{mkdir/rmdir}	make / remove directories
-  \texttt{cp}	copy files and directories
-  \texttt{rm}	remove files
-  \texttt{mv}	move / rename files and directories
-  \texttt{cat}	print files to the terminal
-  \texttt{less/more}	filter output for convenient viewing
-  \texttt{clear}	clear the screen
-  \texttt{chown}	change file and directory owner and group
-  \texttt{chmod}	change file and directory access permissions

* Disks and Files
** Determining Disk and Memory Usage

- The \texttt{df} command is used to determine how much free space is available
  on the mounted storage devices

- The \texttt{du} command shows how much storage space is being used by the
  current directory and all its subdirectories

- Common options for both:
  + -\texttt{h}: prints in human-readable format

- The \texttt{free} command displays usage information about physical memory and swap space

** Finding Files

- Command: \texttt{find path -name pattern}
- Examples:

  + \texttt{find . -name "*.txt"} \\ (find .txt files starting from the current directory)
  + \texttt{find / -name "*.rpm"} \\  (find rpm files starting from the root directory)

- Command: \texttt{locate pattern}
  + uses the (s)locate database, which needs to be updated regularly]
- Example: 
  + \texttt{locate txt} \\ (find any file whose name contains the string “txt”)

** Querying File Types

- Command: \texttt{file [options] file}
- Common options:
  + \texttt{-z}: filters the file through gzip
- Examples:
#+BEGIN_SRC shell -n
  file main.c
  file index.html
  file somearchive.tar.gz
#+END_SRC

** Links

UNIX filesystem has two ways of having multiple places in the
filesystem to access one file:


*** Symbolic links 				      :B_ignoreheading:BMCOL:
    :PROPERTIES: 
    :BEAMER_env: block
    :BEAMER_col: 0.5
    :END:
    - To files and directories
    - Separate file pointing to the original
    - Removing the original leaves hanging symlink
    - Works accross filesystems
    - Slower IO
    - New inode number


*** Hard links 						    :BMCOL:B_example:
    :PROPERTIES: 
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:
    - Not for directories
    - Each link is equally valid way to a file
    - File vanishes only when last link to it is removed
    - Within same filesystem
    - Fast IO
    - Same inode number

** Link example

#+begin_src shell -n
echo aaa > file.normal
ln -s file.normal link.symbolic
ln file.normal link.hard
ls -lia
#+end_src

Output (modified to fit):

#+begin_src shell 
04241 drwxr-xr-x  2 h h	 4096 16:46 .
56643 drwxrwxrwt 18 r r 16384 16:17 ..
24013 -rw-r--r--  2 h h	    4 16:45 file.normal
24013 -rw-r--r--  2 h h	    4 16:45 link.hard
24014 lrwxrwxrwx  1 h h	   11 16:46 link.symbolic -> file.normal
#+end_src

** Disks and Files Command Summary

-  \texttt{df}    report file system disk space usage
-  \texttt{du}    estimate file space usage
-  \texttt{find}  search for files in a directory hierarchy
-  \texttt{locate}  find files by name
-  \texttt{file}  look inside the file to determine type
-  \texttt{ln}  create link to a file
-  \texttt{ln -s}  create symbolic link to a file or directory

* Job Control and IO Redirection
** Shell Job Control (I)

- Job control refers to the ability of the shell to run a command,
  "processes", in the background

- Background processes do not accept input from the shell, useful for:
  - processes that do not produce any output
  - processes that do not interact with the shell
  - processes that will take a long time to execute
- A background process is assigned a job number

** Shell Job Control (II)

- Start a process in the background by appending an ampersand to the
  command, e.g. \texttt{mozilla \&}

- Suspend an active processes by keying \\ \texttt{Ctrl-Z}
- Kill an active processes by keying \\ \texttt{Ctrl-C}
- Send a process to the background by typing \\ \texttt{bg <jobnumber>}
- Send a process to the foreground by typing \\ \texttt{fg <jobnumber>}
- View background and suspended processes with the command: \\ \texttt{jobs}

** Standard input and output

- Unix commands take input (STDIN) and/or produce output
  (STDOUT):
  + STDIN: keyboard
  + STDOUT: screen
  + STDERR: screen

#+ATTR_LaTeX: width=0.99\textwidth
[[file:img/stdinout.pdf]]


** IO Redirection

- IO redirection allows both input and output to be replaced by files
- Output redirection: 
  + The \gt symbol redirects output to a file rather than the terminal
  + Notation \gt\gt appends the output to the end of the file
- Input redirection:
  - The \lt symbol redirects input from a file rather than the terminal
- Examples:

#+BEGIN_SRC shell -n
  ls > temp
  wc -l < temp
  myprog >> myprog.log
#+END_SRC

** IO Redirection: STDERR

- Many Unix commands report to a third default location: standard error, STDERR
- tcsh can not redirect STDERR to a file!
- STDERR redirection in bash: 
  - \texttt{2>} redirects standard error to a file rather than the terminal
  - \texttt{2>\&1} redirects standard error to the same file as
    standard out (equivalent to shorter \texttt{\&>filename})

- Examples:
#+BEGIN_SRC shell -n
 prog > temp 2> log
 prog &> outfile.$$
#+END_SRC

** Pipes

- Pipes redirect the output of one command to the input of another
- This allows the user to combine commands to create more complex ones
- Examples:
#+BEGIN_SRC shell -n
  ls -1 | wc -l
  cat somefile.txt | grep the
  who | grep mary | wc -l
#+END_SRC

 \raggedright Text tools work one line at the time!

** Job Control Command Summary

- \texttt{fg/bg}	send processes to foreground / background
- \texttt{jobs}	list background and suspended processes
- \texttt{>} redirect STDOUT
- \texttt{<} redirect STDIN
- \texttt{2>} redirect STDERR
- \texttt{2>\&1} and \texttt{\&>} redirect both STDOUT and STDERR together
- \texttt{|} connect STDIN to next STDOUT

* Text utilities
** Searching Within Files

- Command: \texttt{grep [options] pattern files}
- Common options:
  + \texttt{-c}: prints a count of the matching lines instead of the default output
  + \texttt{-i}: performs a case-insensitive search
  + \texttt{-n}: also prints out the line number 
  + \texttt{-v}: inverts match, printing out all non-matching lines
- Examples:
  + \texttt{grep bash /etc/passwd} \\ (search for “bash” in the given file)
  + \texttt{grep -v "\land \$" list.txt > cleanlist.txt} \\ (remove empty lines from a file)

** Counting

- Command: \texttt{wc [options] file}
- Common options:
  + \texttt{-c}: byte (ASCII character) count only
  + \texttt{-w}: word count only
  + \texttt{-l}: newline (line) count only
- Examples:
  + \texttt{wc -l file.txt} \\ (line count in a file)
  + \texttt{wc -c <Return>acbd<Ctrl-D> <Ctrl-D>} \\ (number of characters typed, 4)

** Looking at only one end of the file

- Command: \texttt{head [options] file}
- Command: \texttt{tail [options] file}
  + \texttt{-n}: where n is number of lines to display
- Examples:
  + \texttt{head filename} \\ (display 10 first lines by default)
  + \texttt{head -210 filename} | tail \\ (look at line numbers 200-210)
  + \texttt{tail -f continuous.log} \\ (stream end of the file)

** Differences Between Files

- Command: \texttt{diff [options] file1 file2}
- Common options:
  + \texttt{-i}: ignores changes in case
  + \texttt{-B}: ignores changes that just insert or delete blank lines
  + \texttt{-q}: reports only whether the files differ
- Examples:
  + \texttt{diff newfile.txt oldfile.txt} \\ (list differences between the files)
  + \texttt{diff -i newfile.txt oldfile.txt} \\ (list differences with case-insensitive comparison)

** Extracting Columns from Files

- Command: \texttt{cut [options] filename}
- Common options:
  + \texttt{-d delim}: uses the given delimiter, instead of tab
  + \texttt{-c range}: outputs only specified characters
  + \texttt{-f range}: outputs only specified fields
  + (Range in the form N, N-, N-M or -M, counting from 1)
- Examples:
  + \texttt{cut -f1-3 mydata.txt} \\ (cut fields 1 to 3, use tab as separator)
  + \texttt{cut -d”,” -f2 summarydata.csv} \\ (cut field 2, use comma as separator)

** Merging Files in Columns

- Command: \texttt{paste [options] files}
- Common options:
  + \texttt{-d list}: uses delimiters from the list, instead of tabs
  + \texttt{-s}: pastes one file at a time instead of in parallel
- Examples:
  + \texttt{paste -d\”,\” cols1.txt col2.txt} \\ (paste columns from the 2 files with comma as the separator)

** Extracting Rows from Files

- Command: \texttt{split [options] filename}
- Common options:
  + \texttt{-b size}: outputs size bytes per file
  + \texttt{-l size}: outputs size lines per file
- Examples:
  + \texttt{split -l 200 output.db} \\ (split file into 200 line segments)

** Sorting

- Command to sort: \texttt{sort [options] filename}
- Common options:
  + \texttt{-f}: folds lower case characters to upper case
  + \texttt{-b}: ignores leading blanks
  + \texttt{-r}: reverses the sort
  + \texttt{-n}: numeric sorting
- Examples:
  + \texttt{sort -rf mydictionary} \\ (output lines in case-insensitive reverse sorted order)
  + \texttt{sort -n somefile | uniq} \\ (output lines in sorted numeric order)

** Removing Duplicates and Counting

- Command to remove successive identical lines: \\ \texttt{uniq [options] filename}
- Common options:
  + \texttt{-c}: prefix lines by the number of occurrences 
- Examples:
  + \texttt{sort somefile | uniq}  \\ (output lines in sorted order, removing duplicates)
  + \texttt{sort somefile | uniq -c | sort -nr} \\ (count occurrence of lines and show most common first)

** Passing program output as arguments

- White space limited list as arguments to an other program:  \texttt{xargs [options] command}
- Common options:
  + \texttt{-d}: set delimiter 
- Examples:
  + \texttt{cut -d: -f1  /etc/passwd | sort | xargs echo} \\ (compact listing of all logins)
  + \texttt{ls -t | head | grep .ppt | xargs mv -t w/talks/} \\ (move the latest ppt files into the w/talks directory)

** Text Utilities Command Summary

- \texttt{grep}	print lines matching a pattern
- \texttt{wc}	count lines, words and characters
- \texttt{diff}	find differences between two files
- \texttt{cut}	remove sections in columns from files
- \texttt{paste}	merge files as columns
- \texttt{split}	split a file into pieces
- \texttt{sort}	sort lines of text files
- \texttt{head}	output the first part of the file
- \texttt{tail}	output the last part of the file
- \texttt{uniq}	remove duplicate successive lines from a text file
- \texttt{xargs}	pass list as arguments to an other program

* Compression and Archiving
** Compression and Archiving

- Compression and archiving are useful for backups and transferring
  multiple files across a network (via ftp, http, scp, email
  attachments, etc.)

- Compression utilities include 
  + gzip (.gz extension)
  + bzip2 (.bz2 extension)
  + zip (.zip extension – MS compatible)
  + compress (.Z extension)

- Archiving utilities include 
  + tar (.tar extension – most common Unix format)
  + zip (.zip extension – MS compatible)
  + uncompress (.Z extension)

** gzip - GNU compressor

- Command: \texttt{gzip [options] files}
- Common options:
  + \texttt{-d}: decompresses instead of compressing
  + \texttt{-l}: lists compression information
  + \texttt{-t}: tests the file's integrity
- Examples:
  + \texttt{gzip somefile.txt} \\ (compresses the file and renames to somefile.txt.gz)
  + \texttt{gzip -d tarfile.tar.gz} \\ (uncompresses the file and renames to tarfile.tar)
  + bzip2 works similarly to gzip, with a .bz2 filename extension

** tar - archiver

- Command: \texttt{tar [options] [files]}
- Common options:
  + \texttt{-c}: creates a new archive
  + \texttt{-f tarfile}: uses the specified tar filename (instead of stdin / stdout)
  + \texttt{-t}: lists the contents of an archive
  + \texttt{-v}: lists files as they are processed
  + \texttt{-x}: extracts files from an archive
  + \texttt{-z}: filters the archive through gzip
  + \texttt{-j}: filters the archive through bzip2
- Examples:
  + \texttt{tar -cvf docbackup.tar *.doc} \\ (creates a tar file containing all .doc files)
  + \texttt{tar -zxf somearchive.tar.gz} \\ (extracts files in the archive compressed with gzip)
  + \texttt{tar -jtf somearchive.tar.bz2} \\ (lists files in the archive compressed with bzip2)

** zip

- Command: \texttt{zip [options] file1 file2 ...}
- Common options:
  + \texttt{-r}: recurses subdirectories
  + \texttt{-T}: tests the file's integrity
- Examples:
  + \texttt{zip jan-budget.zip jan-budget.sxc} \\ (creates zipped archive containing the single file jan-budget.sxc – note: original file is not modified)
  + \texttt{zip mail-backup.zip mail/*} \\ (creates zipped archive containing everything in the mail directory)

** unzip

- Command: \texttt{unzip [options] zipfile}
- Common options:
  + \texttt{-d directory}: specifies the directory to which to extract
  + \texttt{-l}: lists archive contents without extracting
- Examples:
  + \texttt{unzip -d mail jan-backup.zip} \\ (unzips into mail/ directory)
  + \texttt{unzip -l jan-backup.zip} \\ (lists the contents of the archive)

** Viewing gzipped files

- Command: \texttt{zcat [options] gzipfile}
- Command: \texttt{less [options] gzipfile}
  + less automatically runs zipped file through zcat
- Examples
    + \texttt{zcat jan-backup.gz | grep boss} \\ (grep contents of the
      archive)
    + \texttt{less jan-backup.gz | grep boss} \\(view contents page by
      page)
    + \texttt{gzcat jan-backup.gz | less} \\(view contents page by
      page under Mac OS X)

* Processes
** Process Management

- Unix is a multitasking operating systems that allows more than one
  process to be run at one time
- A running program is called a process
  +  with a unique process ID (PID)
- Processes can run in the foreground or background, and can be
  combined in interesting ways using IO redirection

** Viewing Processes

- Command: \texttt{ps [options]}
- Common options:
  + \texttt{-a}: shows all processes attached to a terminal including those owned by other users
  + \texttt{-l}: displays additional information
  + \texttt{-u}: displays additional information about the user
  + \texttt{-w}: wide format, not truncated at end of line
  + \texttt{-x}: includes processes not attached to a terminal
  + \texttt{-U user}: filters according to specified user

- Examples:
  + \texttt{ps} (list processes in current terminal of current user)
  + \texttt{ps -aux} (list all processes)
  + \texttt{top} - offers similar information, but updates itself continuously

** Terminating Processes

- Processes no longer responding can be terminated with the kill
  command: 
  + \texttt{kill [-signal] PID}

- This command can be executed at various signal strengths. Signal
  strength 9 is the most brutal – only use as a last resort

- Common signals are:
  + \texttt{2}: Interrupt signal (same effect as Ctrl-C)
  + \texttt{9}: Emergency kill signal: cannot be ignored by a process
- Examples:
  + \texttt{kill 1964} \\ (kill process with PID 1964 as gently as possible)
  + \texttt{kill -9 1145} \\ (kill process with PID 1145 using maximum force)

** Signals

Basic communication between UNIX processes is done with  standardized
signals. You have already seen some that are useful for users to
communicate to processes. They have keyboard shot cuts:

- Ctrl-C INT (Interrupt)
- Ctrl-Z TSTP (Terminal SToP)
- Crtl-D EOF (End Of File)

There are many more...

Processes (programs) can handle signals.

** Scheduling Utilities

- cron

  + Allows jobs to be scheduled to run at particular times, and is
    generally used to execute repeated tasks

  + It operates by executing tasks when the system time matches a
    defined pattern. eg. cron can be told to clean up temporary files
    every Monday at 7am

  + The cron service is started at system startup and then wakes up
    every minute to check if a job needs to be started

  + The cron is modified with the crontab command, crontab -l lists

- at

  + at is similar to cron, but is used to execute once-off tasks,
    eg. at can be told to run find the next time 8:15 rolls around by
    typing 'at 08:15 <enter>-c find'<Ctrl-d>

** Editing the Cron

- Use the crontab -e command to edit the cron(, or kcron)

- Cron jobs are specified using an obscure syntax – type man 5 crontab
  for good documentation

- There are 6 columns in the file specifying the following (an * in
  the column leaves it unspecified):

  1. minute (0-59)
  2. hour (0-23)
  3. day of month (1-31)
  4. month (1-12)
  5. day of week (0-7)
  6. the command to be executed

** Cron Examples

#+BEGIN_SRC shell
  # run 5 minutes after midnight, every day
  5 0 * * * $HOME/bin/daily.job >> $HOME/tmp/out 2>&1
  # run at 10pm on weekdays, annoy Joe
  0 22 * * 1-5 mail joe “Where are your kids?”
  # run at 14:15 on the first of every month
  15 14 1 * * $HOME/bin/monthly-reports
#+END_SRC

* Shells
** What is a Shell

- A shell is a command interpreter that executes commands entered
  through the command-line interface

- Several shells are available, most popular are bash (Bourne again
  shell) and tcsh (successor of the original C-shell)

- The default shell is set by the system administrator, but can be
  changed with the \texttt{chsh} command

- *Important*: The default behaviour of UNIX shells is to do everything
  asked without confirmation. Users have to change that to safeguard
  their work!

** Shell capabilities

- Shells mostly offer the same functionality but may differ slightly
  from each other

- Different initialisation files (bash runs .bashrc and .bash\_profile;
  tcsh runs .cshrc)

- Tab completion

- possible command and filename completion (tab in bash vs Ctrl-D in tcsh)

- tcsh should not be used for scripting; can not redirect standard error

- Caveat: Many linux distributions have a bash-compatible, more light-weight
  default shell 

** Environment variables

- They define the user environment and are read from initialisation
  files each time a user logs in
- To view the value of a variable, type \texttt{echo \$VARNAME}
- To see all, type \texttt{printenv}
- Some common environment variables:
  + EDITOR: sets the editor to be used by text viewing programs
  + PATH: specifies directories to be searched for executables
  + SHELL: the default login shell
  + PRINTER: the default printer

-  To reload any initialisation file without having to logout and in
   again, type source <filename>, e.g.

#+BEGIN_SRC shell
    source ~/.bash_profile
#+END_SRC

** Some shell specifics

-  Using bash:
  -  Global initialisation file is \texttt{ $/$etc/profile }
  -  User-specific initialisation files are ~/.bash\_profile and ~/.bashrc
     + sometimes \tilde/.bash\_aliases (Ubuntu)
  -  Command \texttt{set} displays all currently set variables
  -  Syntax to set a variable: export VARNAME="value"
-  Using tcsh:
  -  Global initialisation file is \texttt{ $/$etc/csh.cshrc }
  -  User-specific initialisation file is ~/.cshrc
  -  Command \texttt{setenv} displays all currently set variables
  -  Syntax to set a variable: setenv VARNAME="value"

** The PATH variable

- Specifies the directories that the shell searches to find a command
  or executable
- Any user-directories added to a path should come after the system
  directories
- Directories are searched in the order they appear

#+begin_src sh -n
  echo $PATH
  export PATH=$HOME/bin:$PATH
  export PATH=.:$PATH
#+end_src

** Aliases

- Aliases provide command-substitution functionality. They can be used
  to create new commands or modify the default behaviour of existing
  commands
- The \texttt{alias} command is used to view and create aliases
  + called with no arguments, it prints out the current aliases
  + alias name=value creates a new alias
  + custom user aliases are stored in .bashrc or .cshrc
-  Examples:
  + alias rm='rm -i' (change the behaviour of rm to confirm deletes)
  + alias ll='ls -lLF | less' (create a new command for friendly file listings)

** Bash functions

-  An other way to provide command-substitution functionality is bash functions
-  The \testtt{set} command lists  bash functions
- more versatile than aliases; you can combine any commands
- name() = { commands } creates a new function in .bashrc
-  Examples:
#+BEGIN_SRC shell
  psg()   { ps -AF | grep "$@" | grep -v grep ; }
  killn() { kill `psg "$@" | cut -c9-14` ; }
#+END_SRC

** More text processing tools
Not covered as Perl does the same thing:

- *Command*: \texttt{sed [options] pattern file}
  + Stream editor
- Examples:
  + \texttt{sed 's/U/T/ig' seq} \\ (replace all u's and U's in a file)
  + \texttt{sed G file} \\ (double space the file)

- *Command*: \texttt{awk [options] pattern file}
  + Pattern scanning and processing language
- Examples:
  + \texttt{echo "1   2   3   4" | awk '{print \$2 " and " (\$3+\$4)}'}
    \\ (splits input to words and processes them)

** Further reading

- Introduction to Linux  \\ http://tldp.org/LDP/intro-linux/html/
- Introduction to Command Line Linux \\ http://www.physics.ubc.ca/mbelab/computer/linux-intro/html/
- Beginner's Bash \\ http://linux.org.mt/article/terminal 
- Regular Expressions \\ http://www.zytrax.com/tech/web/regex.htm

* History

** History and Copyright

- Heikki Lehv\auml{}slaiho, heikki.lehvaslaiho@kaust.edu.sa \\
  CBRC, KAUST \\
  September 2011

- Heikki Lehv\auml{}slaiho, heikki@sanbi.ac.za \\
  SANBI, University of Western Cape \\
  March 2007

- John M. Ostrowick, jon@cs.wits.ac.za \\
  School of Computer Science, 
  University of the Witwatersrand \\
  June 2005

This work is licensed under the Creative Commons
Attribution-ShareAlike 3.0 Unported.  To view a copy of this license,
visit http://creativecommons.org/licenses/by-sa/3.0/

